),
h4(),
h5(
"Further details of the simulation mechanism are shared in our publication, Mo Y, Lim C, Mukaka M and Cooper BS. Statistical considerations in the design and analysis of non-inferiority trials with binary endpoints in the presence of non-adherence: a simulation study. Wellcome Open Res 2019, 4:207 (https://doi.org/10.12688/wellcomeopenres.15636.1)."
),
h2(),
h4("Feedback"),
h5(
"Please contact Mo Yin (moyin@tropmedres.ac) to report any issues."
),
h2(),
h4("Lastest update"),
h5("22th February, 2020"),
width = 15
)
),
tabPanel(
"Non-confounding factors",
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input
numericInput(
inputId = "nNC",
label = "Number of participants per arm",
value = 100,
min = 1,
max = NA,
step = NA
),
# Input
sliderInput(
inputId = "NImarginNC",
label = "Non-inferiority margin (absolute scale)",
min = 0.01,
max = 0.3,
value = 0.1,
step = 0.01
),
# Input
sliderInput(
inputId = "adhere.experimentNC",
label = "Expected proportion of adherent participants in experimental arm ",
min = 0.5,
max = 1,
value = 1,
step = 0.05
),
# Input
sliderInput(
inputId = "adhere.stdcareNC",
label = "Expected proportion of adherent participants in standard-of-care arm ",
min = 0.5,
max = 1,
value = 1,
step = 0.05
),
# Input
sliderInput(
inputId = "p.experimentNC",
label = "Expected proportion of participants to have treatment failure in the experimental arm ",
min = 0,
max = 0.5,
value = 0.1,
step = 0.01
),
#Input
sliderInput(
inputId = "p.stdcareNC",
label = "Expected proportion of participants to have treatment failure in the standard-of-care arm ",
min = 0,
max = 0.5,
value = 0.1,
step = 0.01
),
#input
selectInput(
inputId = "significanceNC",
label = "Level of significance",
choices = list("1 sided 97.5%" = "1 sided 97.5%", "1 sided 95%" = "1 sided 95%"),
selected = "1 sided 97.5%",
multiple = FALSE,
selectize = TRUE
),
#calculate!
actionButton(inputId = "runNC",
label = "Calculate!")
),
# Main panel for displaying outputs ----
mainPanel(
tableOutput("DisplayNC"),
p(
"Note: proportion of participants with treatment failure in the experimental arm has been constrained so as not to exceed that in the standard-of-care arm by the non-inferiority margin or more"
)
)
)
),
tabPanel(
"Confounding factors",
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input
numericInput(
inputId = "nC",
label = "Number of participants per arm",
value = 100,
min = 1,
max = NA,
step = NA
),
# Input
sliderInput(
inputId = "NImarginC",
label = "Non-inferiority margin (absolute scale)",
min = 0.01,
max = 0.3,
value = 0.1,
step = 0.01
),
# Input
sliderInput(
inputId = "adhere.experimentC",
label = "Expected proportion of adherent participants in experimental arm ",
min = 0.5,
max = 1,
value = 1,
step = 0.05
),
# Input
sliderInput(
inputId = "adhere.stdcareC",
label = "Expected proportion of adherent participants in standard-of-care arm ",
min = 0.5,
max = 1,
value = 1,
step = 0.05
),
# Input
sliderInput(
inputId = "p.experimentC",
label = "Expected proportion of participants to have treatment failure in the experimental arm ",
min = 0,
max = 0.5,
value = 0.1,
step = 0.01
),
# Input
sliderInput(
inputId = "p.stdcareC",
label = "Expected proportion of participants to have treatment failure in the standard-of-care arm ",
min = 0,
max = 0.5,
value = 0.1,
step = 0.01
),
#input
selectInput(
inputId = "significanceC",
label = "Level of significance",
choices = list("1 sided 97.5%" = "1 sided 97.5%", "1 sided 95%" = "1 sided 95%"),
selected = "1 sided 97.5%",
multiple = FALSE,
selectize = TRUE
),
#input
selectInput(
inputId = "confounder.intervention",
label = "Effect of confounder on taking up the experimental treatment",
choices = list(
"Non-adherent participants with high confounder values from the standard-of-care arm tend to take up the experimental treatment;
non-adherent participants with low confounder values from from the experimental arm tend to to take up the standard-of-care treatment" = "Increase probability",
"Non-adherent participants with low confounder values from the standard-of-care arm tend to take up the experimental treatment;
non-adherent participants with high confounder values from from the experimental arm tend to to take up the standard-of-care treatment" = "Decrease probability"
),
selected = "Non-adherent participants with high confounder values from the standard-of-care arm tend to take up the experimental treatment;
non-adherent participants with low confounder values from from the experimental arm tend to to take up the standard-of-care treatment",
multiple = FALSE,
selectize = TRUE
),
#input
selectInput(
inputId = "confounder.outcome",
label = "Effect of confounder on treatment failure",
choices = list(
"Increase probability" = "Increase probability",
"Decrease probability" = "Decrease probability"
),
selected = "Increase probability",
multiple = FALSE,
selectize = TRUE
),
#input
sliderInput(
inputId = "confounder.eff",
label = "Magnitude of confounding effect on treatment failure
(when estimated with regression using treatment failure as the dependent variable, and confounder as the independent variable)",
min = 0.5,
max = 10,
value = 1,
step = 0.5
),
#calculate!
actionButton(inputId = "runC",
label = "Calculate!")
),
# Main panel for displaying outputs ----
mainPanel(
tableOutput("DisplayC"),
p(
"Note: proportion of participants with treatment failure in the experimental arm has been constrained so as not to exceed that in the standard-of-care arm by the non-inferiority margin or more"
)
)
)
)
)
)
# Define server logic required ----
server <- function(input, output, session) {
#make dynamic slider
observe({
# Control the value, min, max, and step
updateSliderInput(
session,
"p.stdcareNC",
value = input$p.experimentNC,
min = ifelse (
input$p.experimentNC - input$NImarginNC + 0.01 <= 0, 0,
input$p.experimentNC - input$NImarginNC + 0.01),
max = input$p.experimentNC + 0.25,
step = 0.01
)
updateSliderInput(
session,
"p.stdcareC",
value = input$p.experimentC,
min = ifelse (
input$p.experimentC - input$NImarginC + 0.01 <= 0, 0,
input$p.experimentC - input$NImarginC + 0.01),
max = input$p.experimentC + 0.25,
step = 0.01
)
updateSliderInput(
session,
"confounder.eff",
value = input$confounder.outcome,
min = ifelse (input$confounder.outcome == "Increase probability",
0.5, -10),
max = ifelse (input$confounder.outcome == "Increase probability",
10, -0.5),
step = 0.5
)
})
tablevaluesNC <- eventReactive (input$runNC, {
n = input$nNC
p.experiment = input$p.experimentNC
p.stdcare = input$p.stdcareNC
adhere.experiment = input$adhere.experimentNC
adhere.stdcare = input$adhere.stdcareNC
significance = input$significanceNC
NImargin = input$NImarginNC
withProgress(message = 'Calculating Power', value = 0, {
#make up vectors for simulations
estimate.iter = c()
#number of iterations
nIterations = 1000
#significance
ifelse (significance == "1 sided 97.5%",
z <- qnorm(0.975),
z <- qnorm(0.95))
if ((p.experiment - p.stdcare) >= NImargin)
stop (
"Error: NI margin must be positive, and true effect (in terms of negative outcomes) must be less than NI margin in this simulation"
) #built with alternative hypothesis: true effect < NI
id = 1: (2 * n) #create participant id
randomisation = sample(rep(0:1, n)) #randomisation
confounder = rbeta(n = 2 * n, shape1 = 2, shape2 = 2) #confounder beta distribution ranging 0-1
#simulate and derive treatment effect
for (l in 1:nIterations) {
tryCatch({
#COUNTERFACTUAL OUTCOMES with or without intervention (dependent on confounders and intervention)
outcome0 = rbinom(2 * n, prob = p.stdcare, size = 1)
outcome1 = rbinom(2 * n, prob = p.experiment, size = 1)
#INTERVENTION dependent on adherence
intervention = rep(NA, 2 * n)
intervention[sample(which(randomisation == 1), size = adhere.experiment * n)] = 1
intervention[which(randomisation == 1) %in% which(is.na(intervention))] = 0
intervention[sample(which(randomisation == 0), size = adhere.stdcare * n)] = 0
intervention[which(randomisation == 0) %in% which(is.na(intervention))] = 1
#ACTUAL OUTCOMES depend on intervention
outcome = getoutcome(outcome0, outcome1, intervention)
simdata = matrix( data = c(id, randomisation, confounder, intervention, outcome),
nrow = (2 * n))
estimate.iter[[l]] = analysis.estimate(simdata = simdata)
# Increment the progress bar, and update the detail text.
incProgress(1 / nIterations,
detail = paste("Iteration number (out of 1000 iterations)", l))
}, error = function(e) {
cat("ERROR :", conditionMessage(e), "\n")
}) #receive error message if there is an error
}
# mean of power from iterated data
power.calNC = analysis.power(estimate.iter = estimate.iter, z = z, NImargin = NImargin, nIterations = nIterations)
})
Name = c(
"Number of participants per arm",
"Non-inferiority margin (absolute scale)",
"Proportion of participants with treatment failure in the experimental arm",
"Proportion of participants with treatment failure in the standard-of-care arm",
"Proportion of participants who complied to allocated treatment in the experimental arm",
"Proportion of participants who complied to allocated treatment in the standard-of-care arm",
"Level of significance",
"Power using intention to treat analysis",
"Power using per-protocol analysis",
"Power using inverse probability weighting estimation",
"Power using instrumental varible analysis"
)
Value = as.character(
c(
input$nNC,
input$NImarginNC,
input$p.experimentNC,
input$p.stdcareNC,
input$adhere.experimentNC,
input$adhere.stdcareNC,
input$significanceNC,
round(power.calNC[1], 3),
round(power.calNC[2], 3),
round(power.calNC[3], 3),
round(power.calNC[4], 3)
)
)
cbind(Name, Value)
})
output$DisplayNC <- renderTable({
tablevaluesNC()},
hover = TRUE, spacing = 'm')
tablevaluesC <- eventReactive (input$runC, {
n = input$nC
p.experiment = input$p.experimentC
p.stdcare = input$p.stdcareC
adhere.experiment = input$adhere.experimentC
adhere.stdcare = input$adhere.stdcareC
significance = input$significanceC
confounder.eff = input$confounder.eff
confounder.intervention = input$confounder.intervention
confounder.outcome = input$confounder.outcome
NImargin = input$NImarginC
withProgress(message = 'Calculating Power', value = 0, {
#make up vectors for simulations
estimate.iter = eff.conf.outcome = c()
#number of iterations
nIterations = 1000
#significance
ifelse (significance == "1 sided 97.5%",
z <- qnorm(0.975),
z <- qnorm(0.95))
if ((p.experiment - p.stdcare) > NImargin)
stop (
"Error: NI margin must be positive, and true effect (in terms of negative outcomes) must be less than NI margin in this simulation"
) #built with alternative hypothesis: true effect < NI
id = 1:(2 * n) #create participant id
randomisation = sample(rep(0:1, n)) #randomisation
#degree of effect of confounder on outcome
p.experiment.rnd = round(p.experiment/0.05) * 0.05
conf.df.inp = eff.conf.df[which(eff.conf.df$coef.lower == (abs(confounder.eff) - 0.25)),]
conf.df.inpt = conf.df.inp[which(as.character(conf.df.inp$p) == as.character(p.experiment.rnd)),]
shape2min = conf.df.inpt$shape.min
shape2max = conf.df.inpt$shape.max
print(c(shape2min, shape2max))
#simulate and derive treatment effect
for (l in 1:nIterations) {
tryCatch({
confounder = rbeta(n = 2 * n, shape1 = 2, shape2 = 2) #confounder beta distribution ranging 0-1
#COUNTERFACTUAL OUTCOMES with or without intervention (dependent on confounders and intervention)
shape2 = runif(1, min = shape2min, max = shape2max)
if (confounder.outcome == "Increase probability") {
#probability of outcome is drawn from beta distribution shape1<1 and shape2<1 (U shaped) such that confounder correlates with outcome
shape1 = shape2 * p.experiment / (1 - p.experiment) #mean of beta distribution is a/(a+b), a is shape1, b is shape2
p.experiment.ind.gen = rbeta(n = (2 * n), shape1 = shape1, shape2 = shape2 ) #individual probability with mean of p.experiment, in increasing order
p.experiment.ind = p.experiment.ind.gen[order(p.experiment.ind.gen)]
outcome1 = rbinom(2 * n, 1, prob = p.experiment.ind) #increasing confounder value will have increasing probability for outcome
shape1 = shape2 * p.stdcare / (1 - p.stdcare) #mean of beta distribution is a/(a+b), a is shape1, b is shape2
p.stdcare.ind.gen = rbeta(n = (2 * n), shape1 = shape1, shape2 = shape2) #individual probability with mean of p.experiment, in increasing order
p.stdcare.ind = p.stdcare.ind.gen[order(p.stdcare.ind.gen)]
outcome0 = rbinom(2 * n, 1, prob = p.stdcare.ind) #increasing confounder value will have increasing probability for outcome
} else {
shape1 = shape2 * p.experiment / (1 - p.experiment) #mean of beta distribution is a/(a+b), a is shape1, b is shape2
p.experiment.ind.gen = rbeta(n = (2 * n), shape1 = shape1, shape2 = shape2) #individual probability with mean of p.experiment, in decreasing order
p.experiment.ind = p.experiment.ind.gen[order(p.experiment.ind.gen, decreasing = TRUE)]
outcome1 = rbinom(2 * n, 1, prob = p.experiment.ind) #increasing confounder value will have decreasing probability for outcome
shape1 = shape2 * p.stdcare / (1 - p.stdcare) #mean of beta distribution is a/(a+b), a is shape1, b is shape2
p.stdcare.ind.gen = rbeta(n = (2 * n), shape1 = shape1, shape2 = shape2) #individual probability with mean of p.experiment, in increasing order
p.stdcare.ind = p.stdcare.ind.gen[order(p.stdcare.ind.gen, decreasing = TRUE)]
outcome0 = rbinom(2 * n, 1, prob = p.stdcare.ind) #increasing confounder value will have decreasing probability for outcome
}
d = matrix(data = c(id, randomisation, confounder),
nrow = (2 * n))
d.ordered = matrix(cbind(d[order(d[, 3]), ], outcome0, outcome1), ncol = 5) #order confounder in ascending order
d.grouped = rbind(d.ordered[which(d.ordered[, 2] == 1), ], d.ordered[which(d.ordered[, 2] == 0), ])
#INTERVENTION dependent on randomisation and confounders
shape2 = runif(1, min = 2, max = 10)
if (confounder.intervention == "Increase probability") {
shape1 = shape2 * adhere.experiment / (1 - adhere.experiment) #mean of beta distribution is a/(a+b), a is shape1, b is shape2
adhere.experiment.ind.gen = rbeta(n = n, shape1 = shape1, shape2 = shape2) #individual probability with mean of p.experiment, in increasing order
adhere.experiment.ind = adhere.experiment.ind.gen[order(adhere.experiment.ind.gen)]
int.intervention = rbinom(n, 1, prob = adhere.experiment.ind) #increasing confounder value will have decreasing probability for intervention
shape1 = shape2 * (1 - adhere.stdcare) / (1 - (1 - adhere.stdcare)) #mean of beta distribution is a/(a+b), a is shape1, b is shape2
adhere.stdcare.ind.gen = rbeta(n = n, shape1 = shape1, shape2 = shape2) #individual probability with mean of p.experiment, in increasing order
adhere.stdcare.ind = adhere.stdcare.ind.gen[order(adhere.stdcare.ind.gen)]
cont.intervention = rbinom(n, 1, prob = adhere.stdcare.ind)
} else {
shape1 = shape2 * adhere.experiment / (1 - adhere.experiment) #mean of beta distribution is a/(a+b), a is shape1, b is shape2
adhere.experiment.ind.gen = rbeta(n = n, shape1 = shape1, shape2 = shape2)
adhere.experiment.ind = adhere.experiment.ind.gen[order(adhere.experiment.ind.gen, decreasing = TRUE)] #individual probability with mean of p.experiment, in decreasing order
int.intervention = rbinom(n, 1, prob = adhere.experiment.ind) #increasing confounder value will have decreasing probability for outcome
shape1 = shape2 * adhere.stdcare / (1 - adhere.stdcare) #mean of beta distribution is a/(a+b), a is shape1, b is shape2
adhere.stdcare.ind.gen = rbeta(n = n, shape1 = shape1, shape2 = shape2) #individual probability with mean of p.experiment, in decreasing order
adhere.stdcare.ind = adhere.stdcare.ind.gen[order(adhere.stdcare.ind.gen, decreasing = TRUE)]
cont.intervention = rbinom(n, 1, prob = 1 - adhere.stdcare.ind)
}
intervention <- c(int.intervention, cont.intervention)
#ACTUAL OUTCOMES depend on intervention
outcome = getoutcome(d.grouped[, 4], d.grouped[, 5], intervention)
simdata = matrix(cbind(d.grouped[, c(-4, -5)], intervention, outcome), ncol = 5)
estimate.iter[[l]] = analysis.estimate(simdata = simdata)
# Report effect of confounder on probability of outcome
model = speedglm(V4 ~ V3, family = binomial(link = "logit"), data = as.data.frame(d.ordered)) #V3 = confounder, V4 = counterfactual outcome
eff.conf.outcome[[l]] = coefficients(model)[2]
# Increment the progress bar, and update the detail text.
incProgress(1 / nIterations,
detail = paste("Iteration number (out of 1000 iterations)", l))
}, error = function(e) {
cat("ERROR :", conditionMessage(e), "\n")
}) #receive error message if there is an error
}
# mean of power from iterated data
power.calC = analysis.power(estimate.iter = estimate.iter, z = z, NImargin = NImargin, nIterations = nIterations)
#mean of effect of confounder on outcome
eff.conf.outcomeC = sum(unlist(eff.conf.outcome))/nIterations
})
Name = c(
"Number of participants per arm",
"Non-inferiority margin (absolute scale)",
"Proportion of participants with treatment failure in the experimental arm",
"Proportion of participants with treatment failure in the standard-of-care arm",
"Proportion of participants who complied to allocated treatment in the experimental arm",
"Proportion of participants who complied to allocated treatment in the standard-of-care arm",
"Level of significance",
"Effect of confounder on taking up the experimental treatment",
"Effect of confounder on treatment failure",
paste("Magnitude of confounding effect on treatment failure", "(when estimated with regression using treatment failure as the dependent variable, and confounder as the independent variable)", sep = '<br>'),
"Power using intention to treat analysis",
"Power using per-protocol analysis",
"Power using inverse probability weighting estimation",
"Power using instrumental varible analysis"
)
Value = as.character(
c(
input$nC,
input$NImarginC,
input$p.experimentC,
input$p.stdcareC,
input$adhere.experimentC,
input$adhere.stdcareC,
input$significanceC,
input$confounder.intervention,
input$confounder.outcome,
format(round(eff.conf.outcomeC, 1), nsmall = 1),
round(power.calC[1], 3),
round(power.calC[2], 3),
round(power.calC[3], 3),
round(power.calC[4], 3)
)
)
cbind(Name, Value)
})
output$DisplayC <- renderTable({
tablevaluesC()},
hover = TRUE, spacing = 'm',
sanitize.text.function=identity
)
}
# Run the application
shinyApp(ui = ui, server = server)
setwd('/Users/moyin/Documents/nBox/git_projects/NItrialsimulation/shiny/samplesize_nonadherence/')
require('rsconnect')
rsconnect::setAccountInfo(name='moru',
token='30819BAEDD492333CE7CD293F3B08D42',
secret='j24TwHndsiybKqQZERFOt0s3L3ro8IG47/OgpLk/')
deployApp(account="moru",appName="samplesize_nonadherence")
install.packages('rsconnect')
setwd('/Users/moyin/Documents/nBox/git_projects/NItrialsimulation/shiny/samplesize_nonadherence/')
require('rsconnect')
rsconnect::setAccountInfo(name='moru',
token='30819BAEDD492333CE7CD293F3B08D42',
secret='j24TwHndsiybKqQZERFOt0s3L3ro8IG47/OgpLk/')
deployApp(account="moru",appName="samplesize_nonadherence")
setwd('/Users/moyin/Documents/nBox/git_projects/NItrialsimulation/shiny/samplesize_nonadherence/')
require('rsconnect')
rsconnect::setAccountInfo(name='moru',
token='30819BAEDD492333CE7CD293F3B08D42',
secret='j24TwHndsiybKqQZERFOt0s3L3ro8IG47/OgpLk/')
deployApp(account="moru",appName="samplesize_nonadherence")
setwd('/Users/moyin/Documents/nBox/git_projects/NItrialsimulation/shiny/samplesize_nonadherence/')
require('rsconnect')
rsconnect::setAccountInfo(name='moru',
token='30819BAEDD492333CE7CD293F3B08D42',
secret='j24TwHndsiybKqQZERFOt0s3L3ro8IG47/OgpLk/')
deployApp(account="moru",appName="samplesize_nonadherence")
